<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boost.MySQL: boost::mysql::value Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="proposed_for_boost.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Boost.MySQL
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">A Boost.Asio-based client for MySQL</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classboost_1_1mysql_1_1value.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classboost_1_1mysql_1_1value-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::mysql::value Class Reference<div class="ingroups"><a class="el" href="group__values.html">Values</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Represents a value in the database of any of the allowed types. </p>
<p>A <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">boost::mysql::value</a> is a variant-like class. At a given time, it always holds a value of one of the type alternatives, henceforth the stored value. See <a class="el" href="classboost_1_1mysql_1_1value.html#a3c46a8c2c8dca350625405f9e3b06a6e" title="Type of a variant representing the value. ">value::variant_type</a> for the list of all possible type alternatives. A value can be converted to an actual variant using <a class="el" href="classboost_1_1mysql_1_1value.html#a868bf0a302514ee449951545dd0d35af" title="Converts a value to an actual variant of type value::variant_type. ">value::to_variant</a>.</p>
<p>NULL values are considered to hold the value nullptr, with actual type std::nullptr_t. You can check for NULL values using <a class="el" href="classboost_1_1mysql_1_1value.html#a7081bfbcf3e6220e3aa864f1bcf28fa1" title="Checks if the value is NULL. ">value::is_null</a>. There is no distinction between NULL values for different database types (e.g. a NULL value for a TINY column is the same as a NULL value for a VARCHAR column).</p>
<p>To query if a value holds a specific alternative, use <a class="el" href="classboost_1_1mysql_1_1value.html#a56730c9a4b044dc75f0315d17831fb6a" title="Checks if the current type alternative is T. ">value::is</a>. To retrieve the actual value, use <a class="el" href="classboost_1_1mysql_1_1value.html#acb79affba47018280976477aee703610" title="Retrieves the stored value or throws an exception. ">value::get</a> or <a class="el" href="classboost_1_1mysql_1_1value.html#a153384734ef452265c701f8f203c067c" title="Retrieves the stored value as a boost::optional. ">value::get_optional</a>. For certain types, if the actual type is different than the one passed to get/get_optional, these two will try to convert the value to the requested type. The following conversions are considered:</p><ul>
<li>If the actual type is std::uint64_t, the requested type was std::int64_t, and the value is within the range of a std::int64_t, it will be converted to this type.</li>
<li>If the actual type is std::int64_t, the requested type was std::uint64_t, and the value is within the range of a std::uint64_t, it will be converted to this type.</li>
<li>If the actual type was float, and the requested type was double, it will be converted.</li>
</ul>
<p>The mapping from database types (e.g. TINY, VARCHAR...) to C++ types is not one to one. The following lists the mapping from database types to C++ types, together with the ranges and specific considerations for each one.</p>
<ul>
<li>Integral types:<ul>
<li><b>TINYINT</b>. 1 byte integer type. If it is signed, it is represented as a std::int64_t, and its range is between -0x80 and 0x7f. If unsigned, represented as a std::uint64_t, and its range is between 0 and 0xff.</li>
<li><b>SMALLINT</b>. 2 byte integer type. If it is signed, it is represented as a std::int64_t, and its range is between -0x8000 and 0x7fff. If unsigned, represented as a std::uint64_t, and its range is between 0 and 0xffff.</li>
<li><b>MEDIUMINT</b>. 3 byte integer type. If it is signed, it is represented as a std::int64_t, and its range is between -0x800000 and 0x7fffff. If unsigned, represented as a std::uint64_t, and its range is between 0 and 0xffffff.</li>
<li><b>INT</b>. 4 byte integer type. If it is signed, it is represented as a std::int64_t, and its range is between -0x80000000 and 0x7fffffff. If unsigned, represented as a std::uint64_t, and its range is between 0 and 0xffffffff.</li>
<li><b>BIGINT</b>. 8 byte integer type. If it is signed, it is represented as a std::int64_t, and its range is between -0x8000000000000000 and 0x7fffffffffffffff. If unsigned, represented as a std::uint64_t, and its range is between 0 and 0xffffffffffffffff.</li>
<li><b>YEAR</b>. 1 byte integer type used to represent years. Its range is [1901, 2155], plus zero. Zero is often employed to represent invalid year values. We represent zero year here as a numeric 0. YEAR is represented as a std::uint32_t.</li>
</ul>
</li>
<li>Floating point types:<ul>
<li><b>FLOAT</b>. 4 byte floating point type. Represented as float.</li>
<li><b>DOUBLE</b>. 8 byte floating point type. Represented as double.</li>
</ul>
</li>
<li>Date and time types:<ul>
<li><p class="startli"><b>DATE</b>. Represented as a <a class="el" href="group__values.html#ga5aee90bca96275ef12e3417f9776f63f" title="Type representing MySQL DATE data type. ">boost::mysql::date</a>. All dates retrieved from the database are guaranteed to be in the range [<a class="el" href="namespaceboost_1_1mysql.html#ac914d5e53ff14bb984d93ddc58847879" title="The minimum allowed value for boost::mysql::date (0000-01-01). ">boost::mysql::min_date</a>, <a class="el" href="namespaceboost_1_1mysql.html#a662703aaa41f703cb905c5ee5b3ebb8b" title="The maximum allowed value for boost::mysql::date (9999-12-31). ">boost::mysql::max_date</a>]. Note that these limits are slightly more flexible than the official DATE limits.</p>
<p class="startli">If sql_mode is set to ALLOW_INVALID_DATES, MySQL will accept invalid dates, like '2010-02-31'. Furthermore, if strict SQL mode is not enabled, MySQL will accept zero dates, like '0000-00-00', and dates with zero components, like '2010-00-20'. These dates are invalid and not representable as a <a class="el" href="group__values.html#ga5aee90bca96275ef12e3417f9776f63f" title="Type representing MySQL DATE data type. ">boost::mysql::date</a>. In this library, they are all represented as NULL values, instead (std::nullptr_t type). These values can be retrieved from the database in both text queries and prepared statements, but cannot be specified as parameters of prepared statements.</p>
</li>
<li><p class="startli"><b>DATETIME</b>. MySQL representation of a time point without time zone, with a resolution of one microsecond. Represented as a <a class="el" href="group__values.html#ga8597710ffc10b0b95cb49a4b8c15a85d" title="Type representing MySQL DATETIME and TIMESTAMP data types. ">boost::mysql::datetime</a>. All datetimes retrieved from the database are guaranteed to be in the range [<a class="el" href="namespaceboost_1_1mysql.html#a266f0d72cb8da688f9964d182d86a403" title="The minimum allowed value for boost::mysql::datetime. ">boost::mysql::min_datetime</a>, <a class="el" href="namespaceboost_1_1mysql.html#aa2b851a00b8dd5d1ac6aa73f63ff9d13" title="The maximum allowed value for boost::mysql::datetime. ">boost::mysql::max_datetime</a>].</p>
<p class="startli">If sql_mode is set to ALLOW_INVALID_DATES, MySQL will accept datetimes with invalid dates, like '2010-02-31 10:10:10'. Furthermore, if strict SQL mode is not enabled, MySQL will accept zero datetimes, like '0000-00-00 00:00:00', and datetimes with zero date components, like '2010-00-20 00:00:00'. These datetimes are invalid because they do not represent any real time point, and are thus not representable as a <a class="el" href="group__values.html#ga8597710ffc10b0b95cb49a4b8c15a85d" title="Type representing MySQL DATETIME and TIMESTAMP data types. ">boost::mysql::datetime</a>. In this library, they are all represented as NULL values, instead (std::nullptr_t type). These values can be retrieved from the database in both text queries and prepared statements, but cannot be specified as parameters of prepared statements.</p>
</li>
<li><p class="startli"><b>TIMESTAMP</b>. Like DATETIME, it also represents a time point. When inserted, TIMESTAMPs are interpreted as local times, according to the variable time_zone, and converted to UTC for storage. When retrieved, they are converted back to the time zone indicated by time_zone. The retrieved value of a TIMESTAMP field is thus a time point in some local time zone, dictated by the current time_zone variable. As this variable can be changed programmatically, without the client knowing it, we represent TIMESTAMPs without their time zone, using <a class="el" href="group__values.html#ga8597710ffc10b0b95cb49a4b8c15a85d" title="Type representing MySQL DATETIME and TIMESTAMP data types. ">boost::mysql::datetime</a>. TIMESTAMP's range is narrower than DATETIME's, but we do not enforce it in the client.</p>
<p class="startli">If strict SQL mode is not enabled, MySQL accepts zero TIMESTAMPs, like '0000-00-00 00:00:00'. These timestamps are invalid because they do not represent any real time point, and are thus not representable as a <a class="el" href="group__values.html#ga8597710ffc10b0b95cb49a4b8c15a85d" title="Type representing MySQL DATETIME and TIMESTAMP data types. ">boost::mysql::datetime</a>. In this library, they are all represented as NULL values, instead (std::nullptr_t type). These values can be retrieved from the database in both text queries and prepared statements, but cannot be specified as parameters of prepared statements.</p>
</li>
<li><b>TIME</b>. A signed time duration, with a resolution of one microsecond. Represented as a <a class="el" href="group__values.html#ga494d58627935592976a63af024f3fdaf" title="Type representing MySQL TIME data type. ">boost::mysql::time</a> (alias for std::chrono::microseconds). Guaranteed to be in range [<a class="el" href="namespaceboost_1_1mysql.html#a2d5042c0a45183382c59ec3657223582" title="The minimum allowed value for boost::mysql::time. ">boost::mysql::min_time</a> and <a class="el" href="namespaceboost_1_1mysql.html#a3a8535cfaa5b3e6ab04e1c29428558ac" title="The maximum allowed value for boost::mysql::time. ">boost::mysql::max_time</a>].</li>
</ul>
</li>
<li><p class="startli">String types. All text, character and blob types are represented as a boost::string_view. Furthermore, any type without a more specialized representation is exposed as a boost::string_view. Character strings are NOT aware of encoding - they are represented as the string raw bytes. The encoding for each character string column is part of the column metadata, and can be accessed using <a class="el" href="classboost_1_1mysql_1_1field__metadata.html#a76525cadee30c160afd4df3b0d84dd2f" title="Returns the character set (collation) for the column. ">boost::mysql::field_metadata::character_set()</a>.</p>
<p class="startli">The following types are represented as strings in Boost.Mysql:</p><ul>
<li><b>CHAR</b>. Fixed-size character string.</li>
<li><b>BINARY</b>. Fixed-size blob.</li>
<li><b>VARCHAR</b>. Variable size character string with a maximum size.</li>
<li><b>VARBINARY</b>. Variable size blob with a maximum size.</li>
<li><b>TEXT</b> (all sizes). Variable size character string.</li>
<li><b>BLOB</b> (all sizes). Variable size blob.</li>
<li><b>ENUM</b>. Character string with a fixed set of possible values (only one possible).</li>
<li><b>SET</b>. Character string with a fixed set of possible values (many possible).</li>
</ul>
<p class="startli">The following types are not strings per se, but are represented as such because no better representation for them is available at the moment:</p><ul>
<li><b>DECIMAL</b>. A fixed precision numeric value. In this case, the string will contain the textual representation of the number (e.g. the string "20.52" for 20.52).</li>
<li><b>NUMERIC</b>. Alias for DECIMAL.</li>
<li><b>BIT</b>. A bitset between 1 and 64 bits wide. In this case, the string will contain the binary representation of the bitset.</li>
<li><b>GEOMETRY</b>. In this case, the string will contain the binary representation of the geometry type.</li>
</ul>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This is a lightweight, cheap-to-copy class. Strings are represented as string_views, not as owning strings. This implies that if a value is a string, it will point to a <b>externally owned</b> piece of memory (this will typically be a <a class="el" href="classboost_1_1mysql_1_1owning__row.html" title="A row that owns a chunk of memory for its string values. ">boost::mysql::owning_row</a> object). </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3c46a8c2c8dca350625405f9e3b06a6e"><td class="memItemLeft" align="right" valign="top"><a id="a3c46a8c2c8dca350625405f9e3b06a6e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a3c46a8c2c8dca350625405f9e3b06a6e">variant_type</a> = boost::variant2::variant&lt; std::nullptr_t, std::int64_t, std::uint64_t, boost::string_view, float, double, <a class="el" href="group__values.html#ga5aee90bca96275ef12e3417f9776f63f">date</a>, <a class="el" href="group__values.html#ga8597710ffc10b0b95cb49a4b8c15a85d">datetime</a>, <a class="el" href="group__values.html#ga494d58627935592976a63af024f3fdaf">time</a> &gt;</td></tr>
<tr class="memdesc:a3c46a8c2c8dca350625405f9e3b06a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a variant representing the value. <br /></td></tr>
<tr class="separator:a3c46a8c2c8dca350625405f9e3b06a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa13418e5c6897265b126da773c52bc92"><td class="memItemLeft" align="right" valign="top"><a id="aa13418e5c6897265b126da773c52bc92"></a>
BOOST_CXX14_CONSTEXPR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#aa13418e5c6897265b126da773c52bc92">value</a> ()=default</td></tr>
<tr class="memdesc:aa13418e5c6897265b126da773c52bc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a NULL value. <br /></td></tr>
<tr class="separator:aa13418e5c6897265b126da773c52bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a4276d47b9f5625eb6a26903b97d31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49a4276d47b9f5625eb6a26903b97d31"><td class="memTemplItemLeft" align="right" valign="top">BOOST_CXX14_CONSTEXPR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a49a4276d47b9f5625eb6a26903b97d31">value</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a49a4276d47b9f5625eb6a26903b97d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization constructor.  <a href="#a49a4276d47b9f5625eb6a26903b97d31">More...</a><br /></td></tr>
<tr class="separator:a49a4276d47b9f5625eb6a26903b97d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7081bfbcf3e6220e3aa864f1bcf28fa1"><td class="memItemLeft" align="right" valign="top">BOOST_CXX14_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a7081bfbcf3e6220e3aa864f1bcf28fa1">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:a7081bfbcf3e6220e3aa864f1bcf28fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the value is NULL.  <a href="#a7081bfbcf3e6220e3aa864f1bcf28fa1">More...</a><br /></td></tr>
<tr class="separator:a7081bfbcf3e6220e3aa864f1bcf28fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56730c9a4b044dc75f0315d17831fb6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56730c9a4b044dc75f0315d17831fb6a"><td class="memTemplItemLeft" align="right" valign="top">BOOST_CXX14_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a56730c9a4b044dc75f0315d17831fb6a">is</a> () const noexcept</td></tr>
<tr class="memdesc:a56730c9a4b044dc75f0315d17831fb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current type alternative is T.  <a href="#a56730c9a4b044dc75f0315d17831fb6a">More...</a><br /></td></tr>
<tr class="separator:a56730c9a4b044dc75f0315d17831fb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532e38578c3f87c88ccb8a021f473cc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a532e38578c3f87c88ccb8a021f473cc2"><td class="memTemplItemLeft" align="right" valign="top">BOOST_CXX14_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a532e38578c3f87c88ccb8a021f473cc2">is_convertible_to</a> () const noexcept</td></tr>
<tr class="memdesc:a532e38578c3f87c88ccb8a021f473cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current value can be converted to T.  <a href="#a532e38578c3f87c88ccb8a021f473cc2">More...</a><br /></td></tr>
<tr class="separator:a532e38578c3f87c88ccb8a021f473cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb79affba47018280976477aee703610"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb79affba47018280976477aee703610"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#acb79affba47018280976477aee703610">get</a> () const</td></tr>
<tr class="memdesc:acb79affba47018280976477aee703610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stored value or throws an exception.  <a href="#acb79affba47018280976477aee703610">More...</a><br /></td></tr>
<tr class="separator:acb79affba47018280976477aee703610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153384734ef452265c701f8f203c067c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a153384734ef452265c701f8f203c067c"><td class="memTemplItemLeft" align="right" valign="top">boost::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a153384734ef452265c701f8f203c067c">get_optional</a> () const noexcept</td></tr>
<tr class="memdesc:a153384734ef452265c701f8f203c067c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stored value as a boost::optional.  <a href="#a153384734ef452265c701f8f203c067c">More...</a><br /></td></tr>
<tr class="separator:a153384734ef452265c701f8f203c067c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e37c780cf29adb0c2f3cbbd3f53f80c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e37c780cf29adb0c2f3cbbd3f53f80c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a3e37c780cf29adb0c2f3cbbd3f53f80c">get_std_optional</a> () const noexcept</td></tr>
<tr class="memdesc:a3e37c780cf29adb0c2f3cbbd3f53f80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stored value as a std::optional.  <a href="#a3e37c780cf29adb0c2f3cbbd3f53f80c">More...</a><br /></td></tr>
<tr class="separator:a3e37c780cf29adb0c2f3cbbd3f53f80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868bf0a302514ee449951545dd0d35af"><td class="memItemLeft" align="right" valign="top"><a id="a868bf0a302514ee449951545dd0d35af"></a>
BOOST_CXX14_CONSTEXPR <a class="el" href="classboost_1_1mysql_1_1value.html#a3c46a8c2c8dca350625405f9e3b06a6e">variant_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a868bf0a302514ee449951545dd0d35af">to_variant</a> () const noexcept</td></tr>
<tr class="memdesc:a868bf0a302514ee449951545dd0d35af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value to an actual variant of type <a class="el" href="classboost_1_1mysql_1_1value.html#a3c46a8c2c8dca350625405f9e3b06a6e" title="Type of a variant representing the value. ">value::variant_type</a>. <br /></td></tr>
<tr class="separator:a868bf0a302514ee449951545dd0d35af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa782b0c6c2e18f54922d64c0fcb5ba8e"><td class="memItemLeft" align="right" valign="top"><a id="aa782b0c6c2e18f54922d64c0fcb5ba8e"></a>
BOOST_CXX14_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#aa782b0c6c2e18f54922d64c0fcb5ba8e">operator==</a> (const <a class="el" href="classboost_1_1mysql_1_1value.html">value</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aa782b0c6c2e18f54922d64c0fcb5ba8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for equality (type and value). <br /></td></tr>
<tr class="separator:aa782b0c6c2e18f54922d64c0fcb5ba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089a88b58120330af72adc4d42d88f7e"><td class="memItemLeft" align="right" valign="top"><a id="a089a88b58120330af72adc4d42d88f7e"></a>
BOOST_CXX14_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a089a88b58120330af72adc4d42d88f7e">operator!=</a> (const <a class="el" href="classboost_1_1mysql_1_1value.html">value</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a089a88b58120330af72adc4d42d88f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for inequality (type and value). <br /></td></tr>
<tr class="separator:a089a88b58120330af72adc4d42d88f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a5c1c83013a1bdb83034921679c22b317"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a5c1c83013a1bdb83034921679c22b317">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classboost_1_1mysql_1_1value.html">value</a> &amp;v)</td></tr>
<tr class="memdesc:a5c1c83013a1bdb83034921679c22b317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams a value.  <a href="#a5c1c83013a1bdb83034921679c22b317">More...</a><br /></td></tr>
<tr class="separator:a5c1c83013a1bdb83034921679c22b317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f10dc2d0bb16163be535bc8d7c07849"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a9f10dc2d0bb16163be535bc8d7c07849"><td class="memTemplItemLeft" align="right" valign="top">BOOST_CXX14_CONSTEXPR std::array&lt; <a class="el" href="classboost_1_1mysql_1_1value.html">value</a>, sizeof...(Types)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1mysql_1_1value.html#a9f10dc2d0bb16163be535bc8d7c07849">make_values</a> (Types &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9f10dc2d0bb16163be535bc8d7c07849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">mysql::value</a> out of the passed in arguments.  <a href="#a9f10dc2d0bb16163be535bc8d7c07849">More...</a><br /></td></tr>
<tr class="separator:a9f10dc2d0bb16163be535bc8d7c07849"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a49a4276d47b9f5625eb6a26903b97d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a4276d47b9f5625eb6a26903b97d31">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CXX14_CONSTEXPR boost::mysql::value::value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization constructor. </p>
<p>Initializes *this with the same type and value that variant_type(v) would contain. The following exceptions apply:</p><ul>
<li>If T is any unsigned integer, the type will be std::uint64_t and the value, std::uint64_t(v).</li>
<li>If T is any signed integer, the type will be std::int64t and the value, std::int64_t(v).</li>
</ul>
<p>Examples:</p><ul>
<li>value(48) -&gt; std::int64_t</li>
<li>value(std::uint8_t(2)) -&gt; std::uint64_t</li>
<li>value("test") -&gt; boost::string_view </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7081bfbcf3e6220e3aa864f1bcf28fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7081bfbcf3e6220e3aa864f1bcf28fa1">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CXX14_CONSTEXPR bool boost::mysql::value::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the value is NULL. </p>
<p>Returns true only if the value's current type alternative is std::nullptr_t. Equivalent to <a class="el" href="classboost_1_1mysql_1_1value.html#a56730c9a4b044dc75f0315d17831fb6a" title="Checks if the current type alternative is T. ">value::is&lt;std::nullptr_t&gt;()</a>. </p>

</div>
</div>
<a id="a56730c9a4b044dc75f0315d17831fb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56730c9a4b044dc75f0315d17831fb6a">&#9670;&nbsp;</a></span>is()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CXX14_CONSTEXPR bool boost::mysql::value::is </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the current type alternative is T. </p>
<p>T should be one of <a class="el" href="classboost_1_1mysql_1_1value.html#a3c46a8c2c8dca350625405f9e3b06a6e" title="Type of a variant representing the value. ">value::variant_type</a>'s type alternatives. This function does <em>not</em> take into account possible type conversions (e.g. float to double). It returns true only if the current alternative matches T exactly. See <a class="el" href="classboost_1_1mysql_1_1value.html#a532e38578c3f87c88ccb8a021f473cc2" title="Checks if the current value can be converted to T. ">value::is_convertible_to</a> for a version of this function taking conversions into account. This function is faster than <a class="el" href="classboost_1_1mysql_1_1value.html#a532e38578c3f87c88ccb8a021f473cc2" title="Checks if the current value can be converted to T. ">value::is_convertible_to</a>. </p>

</div>
</div>
<a id="a532e38578c3f87c88ccb8a021f473cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532e38578c3f87c88ccb8a021f473cc2">&#9670;&nbsp;</a></span>is_convertible_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CXX14_CONSTEXPR bool boost::mysql::value::is_convertible_to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the current value can be converted to T. </p>
<p>T should be one of <a class="el" href="classboost_1_1mysql_1_1value.html#a3c46a8c2c8dca350625405f9e3b06a6e" title="Type of a variant representing the value. ">value::variant_type</a>'s type alternatives. This function returns true if the current type alternative is T (<a class="el" href="classboost_1_1mysql_1_1value.html#a56730c9a4b044dc75f0315d17831fb6a" title="Checks if the current type alternative is T. ">value::is&lt;T&gt;()</a> returns true) or if there exists a conversion from the current alternative to T that does not cause loss of precision (e.g. float to double). See <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">boost::mysql::value</a> for a list of such conversions.</p>
<p>Use this function if you only need to know if a conversion is possible or not. If you also need to access the stored value, use <a class="el" href="classboost_1_1mysql_1_1value.html#a153384734ef452265c701f8f203c067c" title="Retrieves the stored value as a boost::optional. ">value::get_optional</a> and check the returned optional instead. </p>

</div>
</div>
<a id="acb79affba47018280976477aee703610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb79affba47018280976477aee703610">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T boost::mysql::value::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the stored value or throws an exception. </p>
<p>If the stored value is a T, or can be converted to T using one of the conversions listed in <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">boost::mysql::value</a>'s docs (i.e. when <a class="el" href="classboost_1_1mysql_1_1value.html#a532e38578c3f87c88ccb8a021f473cc2" title="Checks if the current value can be converted to T. ">value::is_convertible_to&lt;T&gt;()</a> returns true), returns the converted value. Otherwise throws boost::variant2::bad_variant_access.</p>
<dl class="section warning"><dt>Warning</dt><dd>The following code pattern, where v is a <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">boost::mysql::value</a>, is correct but inefficient: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (v.is_convertible_to&lt;<span class="keywordtype">double</span>&gt;())</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> d = v.get&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">    <span class="comment">// Do stuff with d</span></div><div class="line">}</div></div><!-- fragment --> Prefer the following: <div class="fragment"><div class="line">std::optional&lt;double&gt; d = v.get_optional&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line"><span class="keywordflow">if</span> (d)</div><div class="line">{</div><div class="line">    <span class="comment">// Do stuff with d</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a153384734ef452265c701f8f203c067c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153384734ef452265c701f8f203c067c">&#9670;&nbsp;</a></span>get_optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt;T&gt; boost::mysql::value::get_optional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the stored value as a boost::optional. </p>
<p>If the stored value is a T, or can be converted to T using one of the conversions listed in <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">boost::mysql::value</a>'s docs (i.e. when <a class="el" href="classboost_1_1mysql_1_1value.html#a532e38578c3f87c88ccb8a021f473cc2" title="Checks if the current value can be converted to T. ">value::is_convertible_to&lt;T&gt;()</a> returns true), returns an optional containing the converted value. Otherwise returns an empty optional. </p>

</div>
</div>
<a id="a3e37c780cf29adb0c2f3cbbd3f53f80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e37c780cf29adb0c2f3cbbd3f53f80c">&#9670;&nbsp;</a></span>get_std_optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt;T&gt; boost::mysql::value::get_std_optional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the stored value as a std::optional. </p>
<p>If the stored value is a T, or can be converted to T using one of the conversions listed in <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">boost::mysql::value</a>'s docs (i.e. when <a class="el" href="classboost_1_1mysql_1_1value.html#a532e38578c3f87c88ccb8a021f473cc2" title="Checks if the current value can be converted to T. ">value::is_convertible_to&lt;T&gt;()</a> returns true), returns an optional containing the converted value. Otherwise returns an empty optional. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5c1c83013a1bdb83034921679c22b317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1c83013a1bdb83034921679c22b317">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1mysql_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Streams a value. </p>
<p>The value should be in the MySQL valid range of values. Concretely, if the value is a date, datetime or time, it should be in the [min_date, max_date], [min_datetime, max_datetime] or [min_time, max_time], respectively. Otherwise, the results are undefined. </p>

</div>
</div>
<a id="a9f10dc2d0bb16163be535bc8d7c07849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f10dc2d0bb16163be535bc8d7c07849">&#9670;&nbsp;</a></span>make_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CXX14_CONSTEXPR std::array&lt; <a class="el" href="classboost_1_1mysql_1_1value.html">value</a>, sizeof...(Types)&gt; make_values </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an array of <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">mysql::value</a> out of the passed in arguments. </p>
<p>Each argument creates an element in the array. It should be possible to construct a <a class="el" href="classboost_1_1mysql_1_1value.html" title="Represents a value in the database of any of the allowed types. ">mysql::value</a> out of every single argument passed in. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1mysql.html">mysql</a></li><li class="navelem"><a class="el" href="classboost_1_1mysql_1_1value.html">value</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
