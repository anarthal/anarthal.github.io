<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boost.MySQL: User manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="proposed_for_boost.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Boost.MySQL
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">A Boost.Asio-based client for MySQL</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Boost.MySQL is a C++11 client for the MySQL database server, based on Boost.Asio.</p>
<h1><a class="anchor" id="why"></a>
Why another MySQL C++ client?</h1>
<ul>
<li>It is fully compatible with Boost.Asio and integrates well with any other library in the Boost.Asio ecosystem (like Boost.Beast).</li>
<li>It supports Boost.Asio's universal asynchronous model, which means you can go asyncrhonous using callbacks, futures or coroutines (including C++20 coroutines).</li>
<li>It is written in modern C++ (C++11) and takes advantage of the latest language features and standard library additions.</li>
<li>It is header only.</li>
</ul>
<h1><a class="anchor" id="building"></a>
Building</h1>
<p>As this is a header-only library, you do not need to build it. However, as it has a bunch of dependencies, we suggest you use CMake to pull them in as you build your application.</p>
<p>Download Boost.MySQL and make it available to your CMake script (we suggest you use CMake's FetchContent module to do this), and then call add_subdirectory() on the Boost.MySQL root directory. This will look for all the required dependencies.</p>
<p>Finally, link your target against the <b>Boost::mysql</b> interface library, and you will be done!</p>
<h1><a class="anchor" id="Requirements"></a>
Requirements</h1>
<ul>
<li>C++11 capable compiler (tested with gcc 7.4, clang 7.0, Apple clang 11.0, MSVC 19.25).</li>
<li>Boost 1.72 or higher.</li>
<li>OpenSSL.</li>
<li>CMake 3.13.0 or higher, if using CMake to build against the library (this is the preferred way).</li>
<li>Tested with MySQL v5.7.29, MySQL v8.0.19, MariaDB v10.3 and MariaDB v10.5.</li>
</ul>
<h1><a class="anchor" id="Features"></a>
Features</h1>
<ul>
<li>Text queries (execution of text SQL queries and data retrieval). MySQL refers to this as the "text protocol", as all information is passed using text (as opposed to prepared statements, see below).</li>
<li>Prepared statements. MySQL refers to this as the "binary protocol", as the result of executing a prepared statement is sent in binary format rather than in text.</li>
<li>Authentication methods (authentication plugins): mysql_native_password and caching_sha2_password. These are the default methods in MySQL 5 and MySQL 8, respectively.</li>
<li>Encrypted connections (TLS).</li>
</ul>
<h1><a class="anchor" id="tutorial"></a>
Tutorial</h1>
<p>This tutorial shows an example of how to use the Boost.MySQL library. It employs synchronous functions with exceptions as error handling strategy, which is the simplest.</p>
<h2><a class="anchor" id="tutorial_code"></a>
Tutorial code</h2>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to a localhost MySQL server.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example uses synchronous functions and handles errors using exceptions.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ASSERT(expr) \</span></div><div class="line"><span class="preprocessor">    if (!(expr)) \</span></div><div class="line"><span class="preprocessor">    { \</span></div><div class="line"><span class="preprocessor">        std::cerr &lt;&lt; &quot;Assertion failed: &quot; #expr &lt;&lt; std::endl; \</span></div><div class="line"><span class="preprocessor">        exit(1); \</span></div><div class="line"><span class="preprocessor">    }</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Prints an employee to std::cout. An employee here is a mysql::row,</span></div><div class="line"><span class="comment"> * which represents a row returned by a SQL query. You can access the values in</span></div><div class="line"><span class="comment"> * the row using row::values(), which returns a vector of mysql::value.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * mysql::value represents a single value returned by MySQL, and is defined to be</span></div><div class="line"><span class="comment"> * a std::variant of all the types MySQL supports.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * row::values() has the same number of elements as fields are in the SQL query,</span></div><div class="line"><span class="comment"> * and in the same order.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> print_employee(<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>&amp; employee)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Employee &#39;&quot;</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>                   <span class="comment">// first_name (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[1] &lt;&lt; <span class="stringliteral">&quot;&#39; earns &quot;</span>            <span class="comment">// last_name  (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[2] &lt;&lt; <span class="stringliteral">&quot; dollars yearly\n&quot;</span>;  <span class="comment">// salary     (type double)</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt;\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Connection parameters that tell us where and how to connect to the MySQL server.</span></div><div class="line"><span class="comment">     * There are two types of parameters:</span></div><div class="line"><span class="comment">     *   - TCP-level connection parameters, identifying the host and port to connect to.</span></div><div class="line"><span class="comment">     *   - MySQL level parameters: database credentials and schema to use.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    boost::asio::ip::tcp::endpoint ep (</div><div class="line">        boost::asio::ip::address_v4::loopback(), <span class="comment">// host</span></div><div class="line">        <a class="code" href="group__connection.html#ga8b06987134c461a221c30c6ef3cdb0d4">boost::mysql::default_port</a>                         <span class="comment">// port</span></div><div class="line">    );</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> params (</div><div class="line">        argv[1],               <span class="comment">// username</span></div><div class="line">        argv[2],               <span class="comment">// password</span></div><div class="line">        <span class="stringliteral">&quot;boost_mysql_examples&quot;</span> <span class="comment">// database to use; leave empty or omit the parameter for no database</span></div><div class="line">    );</div><div class="line">    <span class="comment">// Note: by default, SSL will be used if the server supports it.</span></div><div class="line">    <span class="comment">// connection_params accepts an optional ssl_options argument</span></div><div class="line">    <span class="comment">// determining whether to use SSL or not. See ssl_options and ssl_mode</span></div><div class="line">    <span class="comment">// documentation for further details on SSL.</span></div><div class="line"></div><div class="line">    boost::asio::io_context ctx;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Represents a single connection over TCP to a MySQL server.</span></div><div class="line"><span class="comment">     * Before being able to use it, you have to connect to the server by:</span></div><div class="line"><span class="comment">     *    - Establishing the TCP-level session.</span></div><div class="line"><span class="comment">     *    - Authenticating to the MySQL server.</span></div><div class="line"><span class="comment">     * connection::connect takes care of both.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1socket__connection.html">boost::mysql::tcp_connection</a> conn (ctx);</div><div class="line">    conn.connect(ep, params);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * To issue a SQL query to the database server, use tcp_connection::query, which takes</span></div><div class="line"><span class="comment">     * the SQL to be executed as parameter and returns a resultset object.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Resultset objects represent the result of a query, in tabular format.</span></div><div class="line"><span class="comment">     * They hold metadata describing the fields the resultset holds (in this case, first_name,</span></div><div class="line"><span class="comment">     * last_name and salary). To get the actual data, use fetch_one, fetch_many or fetch_all.</span></div><div class="line"><span class="comment">     * We will use fetch_all, which returns all the received rows as a std::vector.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * We will get all employees working for &#39;High Growth Startup&#39;.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;SELECT first_name, last_name, salary FROM employee WHERE company_id = &#39;HGS&#39;&quot;</span>;</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1resultset.html">boost::mysql::tcp_resultset</a> result = conn.query(sql);</div><div class="line"></div><div class="line">    <span class="comment">// Get all the rows in the resultset</span></div><div class="line">    std::vector&lt;boost::mysql::owning_row&gt; employees = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#ae55f09ab6291e867e67a3a1a30304df7">fetch_all</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; employee: employees)</div><div class="line">    {</div><div class="line">        print_employee(employee);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// We can issue any SQL statement, not only SELECTs. In this case, the returned</span></div><div class="line">    <span class="comment">// resultset will have no fields and no rows</span></div><div class="line">    sql = <span class="stringliteral">&quot;UPDATE employee SET salary = 10000 WHERE first_name = &#39;Underpaid&#39;&quot;</span>;</div><div class="line">    result = conn.query(sql);</div><div class="line">    ASSERT(result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#aec87f1181163a455734e7ede0c71e653">fields</a>().size() == 0); <span class="comment">// fields() returns a vector containing metadata about the query fields</span></div><div class="line"></div><div class="line">    <span class="comment">// Check we have updated our poor intern salary</span></div><div class="line">    result = conn.query(<span class="stringliteral">&quot;SELECT salary FROM employee WHERE first_name = &#39;Underpaid&#39;&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> rows = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#ae55f09ab6291e867e67a3a1a30304df7">fetch_all</a>();</div><div class="line">    ASSERT(rows.size() == 1);</div><div class="line">    <span class="keywordtype">double</span> salary = rows[0].values()[0].get&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">    ASSERT(salary == 10000);</div><div class="line"></div><div class="line">    <span class="comment">// Close the connection. This notifies the MySQL we want to log out</span></div><div class="line">    <span class="comment">// and then closes the underlying socket. This operation implies a network</span></div><div class="line">    <span class="comment">// transfer and thus can fail</span></div><div class="line">    conn.close();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="tutorial_db_setup"></a>
Database setup</h2>
<p>You can run the <code>db_setup.sql</code> file included with the example to set it up, or copy and paste the following commands: </p><div class="fragment"><div class="line"><span class="comment">--</span></div><div class="line"><span class="comment">-- Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">--</span></div><div class="line"><span class="comment">-- Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">--</span></div><div class="line"></div><div class="line"><span class="comment">-- Connection system variables</span></div><div class="line"><span class="keyword">SET</span> NAMES utf8;</div><div class="line"></div><div class="line"><span class="comment">-- Database</span></div><div class="line"><span class="keyword">DROP</span> DATABASE <span class="keywordflow">IF</span> <span class="keyword">EXISTS</span> boost_mysql_examples;</div><div class="line"><span class="keyword">CREATE</span> DATABASE boost_mysql_examples;</div><div class="line">USE boost_mysql_examples;</div><div class="line"></div><div class="line"><span class="comment">-- Tables</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> company(</div><div class="line">    id <span class="keywordtype">CHAR</span>(<span class="stringliteral">10</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span> <span class="keyword">PRIMARY</span> KEY,</div><div class="line">    name <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span></div><div class="line">);</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</div><div class="line">    id <span class="keywordtype">INT</span> <span class="keyword">NOT</span> <span class="stringliteral">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</div><div class="line">    first_name <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div><div class="line">    last_name <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div><div class="line">    salary <span class="keywordtype">DOUBLE</span>,</div><div class="line">    company_id <span class="keywordtype">CHAR</span>(<span class="stringliteral">10</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div><div class="line">    <span class="keyword">FOREIGN</span> KEY (company_id) <span class="keyword">REFERENCES</span> company(id)</div><div class="line">);</div><div class="line">    </div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> company (name, id) <span class="keyword">VALUES</span></div><div class="line">    (<span class="stringliteral">&quot;Award Winning Company, Inc.&quot;</span>, <span class="stringliteral">&quot;AWC&quot;</span>),</div><div class="line">    (<span class="stringliteral">&quot;Sector Global Leader Plc&quot;</span>, <span class="stringliteral">&quot;SGL&quot;</span>),</div><div class="line">    (<span class="stringliteral">&quot;High Growth Startup, Ltd&quot;</span>, <span class="stringliteral">&quot;HGS&quot;</span>)</div><div class="line">;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (first_name, last_name, salary, company_id) <span class="keyword">VALUES</span></div><div class="line">    (<span class="stringliteral">&quot;Efficient&quot;</span>, <span class="stringliteral">&quot;Developer&quot;</span>, <span class="stringliteral">30000</span>, <span class="stringliteral">&quot;AWC&quot;</span>),</div><div class="line">    (<span class="stringliteral">&quot;Lazy&quot;</span>, <span class="stringliteral">&quot;Manager&quot;</span>, <span class="stringliteral">80000</span>, <span class="stringliteral">&quot;AWC&quot;</span>),</div><div class="line">    (<span class="stringliteral">&quot;Good&quot;</span>, <span class="stringliteral">&quot;Team Player&quot;</span>, <span class="stringliteral">35000</span>, <span class="stringliteral">&quot;HGS&quot;</span>),</div><div class="line">    (<span class="stringliteral">&quot;Enormous&quot;</span>, <span class="stringliteral">&quot;Slacker&quot;</span>, <span class="stringliteral">45000</span>, <span class="stringliteral">&quot;SGL&quot;</span>),</div><div class="line">    (<span class="stringliteral">&quot;Coffee&quot;</span>, <span class="stringliteral">&quot;Drinker&quot;</span>, <span class="stringliteral">30000</span>, <span class="stringliteral">&quot;HGS&quot;</span>),</div><div class="line">    (<span class="stringliteral">&quot;Underpaid&quot;</span>, <span class="stringliteral">&quot;Intern&quot;</span>, <span class="stringliteral">15000</span>, <span class="stringliteral">&quot;AWC&quot;</span>)</div><div class="line">;</div><div class="line"></div><div class="line"><span class="comment">-- User</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keywordflow">IF</span> <span class="keyword">EXISTS</span> <span class="stringliteral">&#39;example_user&#39;</span>@<span class="stringliteral">&#39;%&#39;</span>;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="stringliteral">&#39;example_user&#39;</span>@<span class="stringliteral">&#39;%&#39;</span> IDENTIFIED <span class="keyword">WITH</span> <span class="stringliteral">&#39;mysql_native_password&#39;</span>;</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="stringliteral">&#39;example_user&#39;</span>@<span class="stringliteral">&#39;%&#39;</span> IDENTIFIED <span class="keyword">BY</span> <span class="stringliteral">&#39;example_password&#39;</span>;</div><div class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> boost_mysql_examples.* <span class="keyword">TO</span> <span class="stringliteral">&#39;example_user&#39;</span>@<span class="stringliteral">&#39;%&#39;</span>;</div><div class="line">FLUSH PRIVILEGES;</div></div><!-- fragment --><h1><a class="anchor" id="examples_subsection"></a>
Examples</h1>
<h2><a class="anchor" id="query_async_callbacks"></a>
Query, asynchronous with callbacks</h2>
<p>This example demonstrates issuing text queries to the server and reading results, using callbacks. </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/coroutine.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/yield.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">boost::mysql::error_code</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="classboost_1_1mysql_1_1error__info.html">boost::mysql::error_info</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__resultsets.html#gace8b7e3e61dc68ceac4d4d93e5a7d7c1">boost::mysql::tcp_resultset</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="classboost_1_1mysql_1_1owning__row.html">boost::mysql::owning_row</a>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to a localhost MySQL server.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example uses asynchronous functions with callbacks.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example assumes you are already familiar with the basic concepts</span></div><div class="line"><span class="comment"> * of mysql-asio (tcp_connection, resultset, rows, values). If you are not,</span></div><div class="line"><span class="comment"> * please have a look to the query_sync.cpp example.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this library, all asynchronous operations follow Boost.Asio universal</span></div><div class="line"><span class="comment"> * asynchronous models, and thus may be used with callbacks, Boost stackful</span></div><div class="line"><span class="comment"> * coroutines, C++20 coroutines or futures.</span></div><div class="line"><span class="comment"> * The handler signature is always one of:</span></div><div class="line"><span class="comment"> *   - void(error_code): for operations that do not have a &quot;return type&quot; (e.g. handshake)</span></div><div class="line"><span class="comment"> *   - void(error_code, T): for operations that have a &quot;return type&quot; (e.g. query, for which</span></div><div class="line"><span class="comment"> *     T = resultset&lt;StreamType&gt;).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * There are two overloads for all asynchronous operations. One accepts an output error_info&amp;</span></div><div class="line"><span class="comment"> * parameter right before the completion token. This error_info will be populated</span></div><div class="line"><span class="comment"> * in case of error if any extra information provided by the server. The other overload</span></div><div class="line"><span class="comment"> * does not have this error_info&amp; parameter.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Design note: handler signatures in Boost.Asio should have two parameters, at</span></div><div class="line"><span class="comment"> * most, and the first one should be an error_code - otherwise some of the asynchronous</span></div><div class="line"><span class="comment"> * features (e.g. coroutines) won&#39;t work. This is why error_info is not part of any</span></div><div class="line"><span class="comment"> * of the handler signatures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ASSERT(expr) \</span></div><div class="line"><span class="preprocessor">    if (!(expr)) \</span></div><div class="line"><span class="preprocessor">    { \</span></div><div class="line"><span class="preprocessor">        std::cerr &lt;&lt; &quot;Assertion failed: &quot; #expr &lt;&lt; std::endl; \</span></div><div class="line"><span class="preprocessor">        exit(1); \</span></div><div class="line"><span class="preprocessor">    }</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> print_employee(<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>&amp; employee)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Employee &#39;&quot;</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>                   <span class="comment">// first_name (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[1] &lt;&lt; <span class="stringliteral">&quot;&#39; earns &quot;</span>            <span class="comment">// last_name  (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[2] &lt;&lt; <span class="stringliteral">&quot; dollars yearly\n&quot;</span>;  <span class="comment">// salary     (type double)</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> die_on_error(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a>&amp; err,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1error__info.html">boost::mysql::error_info</a>&amp; info = <a class="code" href="classboost_1_1mysql_1_1error__info.html">boost::mysql::error_info</a>()</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; info.message() &lt;&lt; std::endl;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class </span>application</div><div class="line">{</div><div class="line">    boost::asio::ip::tcp::endpoint ep;            <span class="comment">// Physical endpoint to connect to</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> conn_params;  <span class="comment">// MySQL credentials and other connection config</span></div><div class="line">    boost::asio::io_context ctx;                  <span class="comment">// boost::asio context</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1socket__connection.html">boost::mysql::tcp_connection</a> connection;      <span class="comment">// Represents the connection to the MySQL server</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1resultset.html">boost::mysql::tcp_resultset</a> resultset;        <span class="comment">// A result from a query</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1error__info.html">boost::mysql::error_info</a> additional_info;     <span class="comment">// Will be populated with additional information about any errors</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    application(<span class="keyword">const</span> <span class="keywordtype">char</span>* username, <span class="keyword">const</span> <span class="keywordtype">char</span>* password) :</div><div class="line">        ep (<a class="code" href="namespaceboost.html">boost</a>::asio::ip::address_v4::loopback(), <a class="code" href="namespaceboost.html">boost</a>::mysql::<a class="code" href="group__connection.html#ga8b06987134c461a221c30c6ef3cdb0d4">default_port</a>),</div><div class="line">        conn_params(username, password, <span class="stringliteral">&quot;boost_mysql_examples&quot;</span>),</div><div class="line">        connection(ctx)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> start() { connect(); }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> connect()</div><div class="line">    {</div><div class="line">        connection.<a class="code" href="classboost_1_1mysql_1_1socket__connection.html#ae3e85fc3c479ffc2663d3f3ad0c7cc83">async_connect</a>(ep, conn_params, additional_info, [<span class="keyword">this</span>](<a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a> err) {</div><div class="line">            die_on_error(err, additional_info);</div><div class="line">            query_employees();</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> query_employees()</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;SELECT first_name, last_name, salary FROM employee WHERE company_id = &#39;HGS&#39;&quot;</span>;</div><div class="line">        connection.<a class="code" href="classboost_1_1mysql_1_1connection.html#a81a270c6c7de3e51db32f820d6fbe20b">async_query</a>(sql, additional_info, [<span class="keyword">this</span>](<a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a> err, <a class="code" href="group__resultsets.html#gace8b7e3e61dc68ceac4d4d93e5a7d7c1">tcp_resultset</a>&amp;&amp; result) {</div><div class="line">            die_on_error(err, additional_info);</div><div class="line">            resultset = std::move(result);</div><div class="line">            resultset.<a class="code" href="classboost_1_1mysql_1_1resultset.html#a89ac804b741bcc0cdbc6d4a195c3c2c8">async_fetch_all</a>(additional_info, [<span class="keyword">this</span>](<a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a> err, <span class="keyword">const</span> std::vector&lt;owning_row&gt;&amp; rows) {</div><div class="line">                die_on_error(err, additional_info);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; employee: rows)</div><div class="line">                {</div><div class="line">                    print_employee(employee);</div><div class="line">                }</div><div class="line">                update_slacker();</div><div class="line">            });</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> update_slacker()</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;UPDATE employee SET salary = 15000 WHERE last_name = &#39;Slacker&#39;&quot;</span>;</div><div class="line">        connection.<a class="code" href="classboost_1_1mysql_1_1connection.html#a81a270c6c7de3e51db32f820d6fbe20b">async_query</a>(sql, additional_info,</div><div class="line">                [<span class="keyword">this</span>](<a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a> err, <a class="code" href="group__resultsets.html#gace8b7e3e61dc68ceac4d4d93e5a7d7c1">tcp_resultset</a>&amp;&amp; result) {</div><div class="line">            die_on_error(err, additional_info);</div><div class="line">            ASSERT(result.fields().size() == 0);</div><div class="line">            query_intern();</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> query_intern()</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;SELECT salary FROM employee WHERE last_name = &#39;Slacker&#39;&quot;</span>;</div><div class="line">        connection.<a class="code" href="classboost_1_1mysql_1_1connection.html#a81a270c6c7de3e51db32f820d6fbe20b">async_query</a>(sql, additional_info, [<span class="keyword">this</span>](<a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a> err, <a class="code" href="group__resultsets.html#gace8b7e3e61dc68ceac4d4d93e5a7d7c1">tcp_resultset</a>&amp;&amp; result) {</div><div class="line">            die_on_error(err, additional_info);</div><div class="line">            resultset = std::move(result);</div><div class="line">            resultset.<a class="code" href="classboost_1_1mysql_1_1resultset.html#a89ac804b741bcc0cdbc6d4a195c3c2c8">async_fetch_all</a>(additional_info, [<span class="keyword">this</span>](<a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a> err, <span class="keyword">const</span> std::vector&lt;owning_row&gt;&amp; rows) {</div><div class="line">                die_on_error(err, additional_info);</div><div class="line">                ASSERT(rows.size() == 1);</div><div class="line">                <span class="keyword">auto</span> salary = rows[0].values()[0].get&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">                ASSERT(salary == 15000);</div><div class="line">                close();</div><div class="line">            });</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> close()</div><div class="line">    {</div><div class="line">        <span class="comment">// Notify the MySQL server we want to quit and then close the socket</span></div><div class="line">        connection.<a class="code" href="classboost_1_1mysql_1_1socket__connection.html#aedd89189c0c355bc940617938ecc2662">async_close</a>(additional_info, [<span class="keyword">this</span>](<a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a> err) {</div><div class="line">            die_on_error(err, additional_info);</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run() { ctx.run(); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt;\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    application app (argv[1], argv[2]);</div><div class="line">    app.start(); <span class="comment">// starts the async chain</span></div><div class="line">    app.run(); <span class="comment">// run the asio::io_context until the async chain finishes</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="query_async_futures"></a>
Query, asynchronous with futures</h2>
<p>This example demonstrates issuing text queries to the server and reading results, using futures. </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/use_future.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">boost::mysql::error_code</a>;</div><div class="line"><span class="keyword">using</span> boost::asio::use_future;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to a localhost MySQL server.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example uses asynchronous functions with futures.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example assumes you are already familiar with the basic concepts</span></div><div class="line"><span class="comment"> * of mysql-asio (tcp_connection, resultset, rows, values). If you are not,</span></div><div class="line"><span class="comment"> * please have a look to the query_sync.cpp example.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this library, all asynchronous operations follow Boost.Asio universal</span></div><div class="line"><span class="comment"> * asynchronous models, and thus may be used with callbacks, Boost stackful</span></div><div class="line"><span class="comment"> * coroutines, C++20 coroutines or futures.</span></div><div class="line"><span class="comment"> * The handler signature is always one of:</span></div><div class="line"><span class="comment"> *   - void(error_code): for operations that do not have a &quot;return type&quot; (e.g. handshake)</span></div><div class="line"><span class="comment"> *   - void(error_code, T): for operations that have a &quot;return type&quot; (e.g. query, for which</span></div><div class="line"><span class="comment"> *     T = resultset&lt;StreamType&gt;).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * There are two overloads for all asynchronous operations. One accepts an output error_info&amp;</span></div><div class="line"><span class="comment"> * parameter right before the completion token. This error_info will be populated</span></div><div class="line"><span class="comment"> * in case of error if any extra information provided by the server. The other overload</span></div><div class="line"><span class="comment"> * does not have this error_info&amp; parameter.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Design note: handler signatures in Boost.Asio should have two parameters, at</span></div><div class="line"><span class="comment"> * most, and the first one should be an error_code - otherwise some of the asynchronous</span></div><div class="line"><span class="comment"> * features (e.g. coroutines) won&#39;t work. This is why error_info is not part of any</span></div><div class="line"><span class="comment"> * of the handler signatures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> print_employee(<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>&amp; employee)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Employee &#39;&quot;</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>                   <span class="comment">// first_name (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[1] &lt;&lt; <span class="stringliteral">&quot;&#39; earns &quot;</span>            <span class="comment">// last_name  (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[2] &lt;&lt; <span class="stringliteral">&quot; dollars yearly\n&quot;</span>;  <span class="comment">// salary     (type double)</span></div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * A boost::asio::io_context plus a thread that calls context.run().</span></div><div class="line"><span class="comment"> * We encapsulate this here to ensure correct shutdown even in case of</span></div><div class="line"><span class="comment"> * error (exception), when we should first reset the work guard, to</span></div><div class="line"><span class="comment"> * stop the io_context, and then join the thread. Failing to do so</span></div><div class="line"><span class="comment"> * may cause your application to not stop (if the work guard is not</span></div><div class="line"><span class="comment"> * reset) or to terminate badly (if the thread is not joined).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class </span>application</div><div class="line">{</div><div class="line">    boost::asio::io_context ctx_;</div><div class="line">    boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt; guard_;</div><div class="line">    std::thread runner_;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    application(): guard_(ctx_.get_executor()), runner_([this] { ctx_.run(); }) {}</div><div class="line">    application(<span class="keyword">const</span> application&amp;) = <span class="keyword">delete</span>;</div><div class="line">    application(application&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">    application&amp; operator=(<span class="keyword">const</span> application&amp;) = <span class="keyword">delete</span>;</div><div class="line">    application&amp; operator=(application&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">    ~application()</div><div class="line">    {</div><div class="line">        guard_.reset();</div><div class="line">        runner_.join();</div><div class="line">    }</div><div class="line">    boost::asio::io_context&amp; context() { <span class="keywordflow">return</span> ctx_; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt;\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Context and connections</span></div><div class="line">    application app; <span class="comment">// boost::asio::io_context and a thread that calls run()</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1socket__connection.html">boost::mysql::tcp_connection</a> conn (app.context());</div><div class="line"></div><div class="line">    boost::asio::ip::tcp::endpoint ep (</div><div class="line">        boost::asio::ip::address_v4::loopback(), <span class="comment">// host</span></div><div class="line">        <a class="code" href="group__connection.html#ga8b06987134c461a221c30c6ef3cdb0d4">boost::mysql::default_port</a>                 <span class="comment">// port</span></div><div class="line">    );</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> params (</div><div class="line">        argv[1],               <span class="comment">// username</span></div><div class="line">        argv[2],               <span class="comment">// password</span></div><div class="line">        <span class="stringliteral">&quot;boost_mysql_examples&quot;</span> <span class="comment">// database to use; leave empty or omit the parameter for no database</span></div><div class="line">    );</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Perform the TCP connect and MySQL handshake.</span></div><div class="line"><span class="comment">     * Calling async_connect triggers the</span></div><div class="line"><span class="comment">     * operation, and calling future::get() blocks the current thread until</span></div><div class="line"><span class="comment">     * it completes. get() will throw an exception if the operation fails.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    std::future&lt;void&gt; fut = conn.async_connect(ep, params, use_future);</div><div class="line">    fut.get();</div><div class="line"></div><div class="line">    <span class="comment">// Issue the query to the server</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;SELECT first_name, last_name, salary FROM employee WHERE company_id = &#39;HGS&#39;&quot;</span>;</div><div class="line">    std::future&lt;boost::mysql::tcp_resultset&gt; resultset_fut = conn.async_query(sql, use_future);</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1resultset.html">boost::mysql::tcp_resultset</a> result = resultset_fut.get();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Get all rows in the resultset. We will employ resultset::async_fetch_one(),</span></div><div class="line"><span class="comment">     * which returns a single row at every call. The returned row is a pointer</span></div><div class="line"><span class="comment">     * to memory owned by the resultset, and is re-used for each row. Thus, returned</span></div><div class="line"><span class="comment">     * rows remain valid until the next call to async_fetch_one(). When no more</span></div><div class="line"><span class="comment">     * rows are available, async_fetch_one returns nullptr.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>* current_row = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#ab9f1dab2fbf86333c8453cee4e549033">async_fetch_one</a>(use_future).get())</div><div class="line">    {</div><div class="line">        print_employee(*current_row);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Notify the MySQL server we want to quit, then close the underlying connection.</span></div><div class="line">    conn.async_close(use_future).get();</div><div class="line"></div><div class="line">    <span class="comment">// application dtor. stops io_context and then joins the thread</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="query_async_coroutines"></a>
Query, asynchronous with coroutines</h2>
<p>This example demonstrates issuing text queries to the server and reading results, using coroutines. </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/spawn.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">boost::mysql::error_code</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="classboost_1_1mysql_1_1error__info.html">boost::mysql::error_info</a>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to a localhost MySQL server.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example uses asynchronous functions with coroutines.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example assumes you are already familiar with the basic concepts</span></div><div class="line"><span class="comment"> * of mysql-asio (tcp_connection, resultset, rows, values). If you are not,</span></div><div class="line"><span class="comment"> * please have a look to the query_sync.cpp example.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this library, all asynchronous operations follow Boost.Asio universal</span></div><div class="line"><span class="comment"> * asynchronous models, and thus may be used with callbacks, Boost stackful</span></div><div class="line"><span class="comment"> * coroutines, C++20 coroutines or futures.</span></div><div class="line"><span class="comment"> * The handler signature is always one of:</span></div><div class="line"><span class="comment"> *   - void(error_code): for operations that do not have a &quot;return type&quot; (e.g. handshake)</span></div><div class="line"><span class="comment"> *   - void(error_code, T): for operations that have a &quot;return type&quot; (e.g. query, for which</span></div><div class="line"><span class="comment"> *     T = resultset&lt;StreamType&gt;).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * There are two overloads for all asynchronous operations. One accepts an output error_info&amp;</span></div><div class="line"><span class="comment"> * parameter right before the completion token. This error_info will be populated</span></div><div class="line"><span class="comment"> * in case of error if any extra information provided by the server. The other overload</span></div><div class="line"><span class="comment"> * does not have this error_info&amp; parameter.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Design note: handler signatures in Boost.Asio should have two parameters, at</span></div><div class="line"><span class="comment"> * most, and the first one should be an error_code - otherwise some of the asynchronous</span></div><div class="line"><span class="comment"> * features (e.g. coroutines) won&#39;t work. This is why error_info is not part of any</span></div><div class="line"><span class="comment"> * of the handler signatures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> print_employee(<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>&amp; employee)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Employee &#39;&quot;</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>                   <span class="comment">// first_name (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[1] &lt;&lt; <span class="stringliteral">&quot;&#39; earns &quot;</span>            <span class="comment">// last_name  (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[2] &lt;&lt; <span class="stringliteral">&quot; dollars yearly\n&quot;</span>;  <span class="comment">// salary     (type double)</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Throws an exception if an operation failed</span></div><div class="line"><span class="keywordtype">void</span> check_error(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">error_code</a>&amp; err,</div><div class="line">    <span class="keyword">const</span> error_info&amp; info = {}</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (err)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">throw</span> boost::system::system_error(err, info.message());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt;\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Context and connections</span></div><div class="line">    boost::asio::io_context ctx;</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1socket__connection.html">boost::mysql::tcp_connection</a> conn (ctx);</div><div class="line"></div><div class="line">    boost::asio::ip::tcp::endpoint ep (</div><div class="line">        boost::asio::ip::address_v4::loopback(), <span class="comment">// host</span></div><div class="line">        <a class="code" href="group__connection.html#ga8b06987134c461a221c30c6ef3cdb0d4">boost::mysql::default_port</a>                 <span class="comment">// port</span></div><div class="line">    );</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> params (</div><div class="line">        argv[1],               <span class="comment">// username</span></div><div class="line">        argv[2],               <span class="comment">// password</span></div><div class="line">        <span class="stringliteral">&quot;boost_mysql_examples&quot;</span> <span class="comment">// database to use; leave empty or omit the parameter for no database</span></div><div class="line">    );</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * The entry point. We spawn a stackful coroutine using boost::asio::spawn</span></div><div class="line"><span class="comment">     * (see https://www.boost.org/doc/libs/1_72_0/doc/html/boost_asio/reference/spawn.html).</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * The coroutine will actually start running when we call io_context::run().</span></div><div class="line"><span class="comment">     * It will suspend every time we call one of the asynchronous functions, saving</span></div><div class="line"><span class="comment">     * all information it needs for resuming. When the asynchronous operation completes,</span></div><div class="line"><span class="comment">     * the coroutine will resume in the point it was left.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * The return type of a coroutine is the second argument to the handler signature</span></div><div class="line"><span class="comment">     * for the asynchronous operation. For example, connection::query has a handler</span></div><div class="line"><span class="comment">     * signature of void(error_code, resultset&lt;Stream&gt;), so the coroutine return</span></div><div class="line"><span class="comment">     * type is resultset&lt;Stream&gt;.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    boost::asio::spawn(ctx.get_executor(), [&amp;conn, ep, params](boost::asio::yield_context yield) {</div><div class="line">        <span class="comment">// This error_code and error_info will be filled if an</span></div><div class="line">        <span class="comment">// operation fails. We will check them for every operation we perform.</span></div><div class="line">        <a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">boost::mysql::error_code</a> ec;</div><div class="line">        <a class="code" href="classboost_1_1mysql_1_1error__info.html">boost::mysql::error_info</a> additional_info;</div><div class="line"></div><div class="line">        <span class="comment">// Connect to server</span></div><div class="line">        conn.async_connect(ep, params, additional_info, yield[ec]);</div><div class="line">        check_error(ec);</div><div class="line"></div><div class="line">        <span class="comment">// Issue the query to the server</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;SELECT first_name, last_name, salary FROM employee WHERE company_id = &#39;HGS&#39;&quot;</span>;</div><div class="line">        <a class="code" href="classboost_1_1mysql_1_1resultset.html">boost::mysql::tcp_resultset</a> result = conn.async_query(sql, additional_info, yield[ec]);</div><div class="line">        check_error(ec, additional_info);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        /**</span></div><div class="line"><span class="comment">         * Get all rows in the resultset. We will employ resultset::async_fetch_one(),</span></div><div class="line"><span class="comment">         * which returns a single row at every call. The returned row is a pointer</span></div><div class="line"><span class="comment">         * to memory owned by the resultset, and is re-used for each row. Thus, returned</span></div><div class="line"><span class="comment">         * rows remain valid until the next call to async_fetch_one(). When no more</span></div><div class="line"><span class="comment">         * rows are available, async_fetch_one returns nullptr.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>* row = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#ab9f1dab2fbf86333c8453cee4e549033">async_fetch_one</a>(additional_info, yield[ec]);</div><div class="line">            check_error(ec, additional_info);</div><div class="line">            <span class="keywordflow">if</span> (!row) <span class="keywordflow">break</span>; <span class="comment">// No more rows available</span></div><div class="line">            print_employee(*row);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Notify the MySQL server we want to quit, then close the underlying connection.</span></div><div class="line">        conn.async_close(additional_info, yield[ec]);</div><div class="line">        check_error(ec, additional_info);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Don&#39;t forget to call run()! Otherwise, your program</span></div><div class="line">    <span class="comment">// will not spawn the coroutine and will do nothing.</span></div><div class="line">    ctx.run();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="query_async_coroutinescpp20"></a>
Query, asynchronous with C++20 coroutines</h2>
<p>This example demonstrates issuing text queries to the server and reading results, using C++20 coroutines (boost::asio::use_awaitable). </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/co_spawn.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/use_awaitable.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/awaitable.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/detached.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/use_future.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__error.html#gaff8c71ba89eb874c8d2a7e1221942ccd">boost::mysql::error_code</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="classboost_1_1mysql_1_1error__info.html">boost::mysql::error_info</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef BOOST_ASIO_HAS_CO_AWAIT</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to a localhost MySQL server.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example uses asynchronous functions with C++20 coroutines</span></div><div class="line"><span class="comment"> * (boost::asio::use_awaitable). It also demonstrates using</span></div><div class="line"><span class="comment"> * defaulted completion tokens (so that you do not have to write</span></div><div class="line"><span class="comment"> * boost::asio::use_awaitable in every async op).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example assumes you are already familiar with the basic concepts</span></div><div class="line"><span class="comment"> * of mysql-asio (tcp_connection, resultset, rows, values). If you are not,</span></div><div class="line"><span class="comment"> * please have a look to the query_sync.cpp example.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this library, all asynchronous operations follow Boost.Asio universal</span></div><div class="line"><span class="comment"> * asynchronous models, and thus may be used with callbacks, Boost stackful</span></div><div class="line"><span class="comment"> * coroutines, C++20 coroutines or futures.</span></div><div class="line"><span class="comment"> * The handler signature is always one of:</span></div><div class="line"><span class="comment"> *   - void(error_code): for operations that do not have a &quot;return type&quot; (e.g. handshake)</span></div><div class="line"><span class="comment"> *   - void(error_code, T): for operations that have a &quot;return type&quot; (e.g. query, for which</span></div><div class="line"><span class="comment"> *     T = resultset&lt;StreamType&gt;).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * There are two overloads for all asynchronous operations. One accepts an output error_info&amp;</span></div><div class="line"><span class="comment"> * parameter right before the completion token. This error_info will be populated</span></div><div class="line"><span class="comment"> * in case of error if any extra information provided by the server. The other overload</span></div><div class="line"><span class="comment"> * does not have this error_info&amp; parameter.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Design note: handler signatures in Boost.Asio should have two parameters, at</span></div><div class="line"><span class="comment"> * most, and the first one should be an error_code - otherwise some of the asynchronous</span></div><div class="line"><span class="comment"> * features (e.g. coroutines) won&#39;t work. This is why error_info is not part of any</span></div><div class="line"><span class="comment"> * of the handler signatures.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> print_employee(<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>&amp; employee)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Employee &#39;&quot;</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>                   <span class="comment">// first_name (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[1] &lt;&lt; <span class="stringliteral">&quot;&#39; earns &quot;</span>            <span class="comment">// last_name  (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[2] &lt;&lt; <span class="stringliteral">&quot; dollars yearly\n&quot;</span>;  <span class="comment">// salary     (type double)</span></div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * A boost::asio::io_context plus a thread that calls context.run().</span></div><div class="line"><span class="comment"> * We encapsulate this here to ensure correct shutdown even in case of</span></div><div class="line"><span class="comment"> * error (exception), when we should first reset the work guard, to</span></div><div class="line"><span class="comment"> * stop the io_context, and then join the thread. Failing to do so</span></div><div class="line"><span class="comment"> * may cause your application to not stop (if the work guard is not</span></div><div class="line"><span class="comment"> * reset) or to terminate badly (if the thread is not joined).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class </span>application</div><div class="line">{</div><div class="line">    boost::asio::io_context ctx_;</div><div class="line">    boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt; guard_;</div><div class="line">    std::thread runner_;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    application(): guard_(ctx_.get_executor()), runner_([this] { ctx_.run(); }) {}</div><div class="line">    application(<span class="keyword">const</span> application&amp;) = <span class="keyword">delete</span>;</div><div class="line">    application(application&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">    application&amp; operator=(<span class="keyword">const</span> application&amp;) = <span class="keyword">delete</span>;</div><div class="line">    application&amp; operator=(application&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">    ~application()</div><div class="line">    {</div><div class="line">        guard_.reset();</div><div class="line">        runner_.join();</div><div class="line">    }</div><div class="line">    boost::asio::io_context&amp; context() { <span class="keywordflow">return</span> ctx_; }</div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Default completion tokens are associated to executors.</span></div><div class="line"><span class="comment"> * boost::mysql::socket_connection objects use the same executor</span></div><div class="line"><span class="comment"> * as the underlying stream (socket). boost::mysql::tcp_connection</span></div><div class="line"><span class="comment"> * objects use boost::asio::ip::tcp::socket, which use the polymorphic</span></div><div class="line"><span class="comment"> * boost::asio::executor as executor type, which does not have a default</span></div><div class="line"><span class="comment"> * completion token associated.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We will use the io_context&#39;s executor as base executor. We will then</span></div><div class="line"><span class="comment"> * use use_awaitable_t::executor_with_default on this type, which creates</span></div><div class="line"><span class="comment"> * a new executor type acting the same as the base executor, but having</span></div><div class="line"><span class="comment"> * use_awaitable_t as default completion token type.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We will then obtain the connection type to use by rebinding</span></div><div class="line"><span class="comment"> * the usual tcp_connection to our new executor type, coro_executor_type.</span></div><div class="line"><span class="comment"> * This is equivalent to using a boost::mysql::connection&lt;socket_type&gt;,</span></div><div class="line"><span class="comment"> * where socket_type is a TCP socket that uses our coro_executor_type.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The reward for this hard work is not having to pass the completion</span></div><div class="line"><span class="comment"> * token (boost::asio::use_awaitable) to any of the asynchronous operations</span></div><div class="line"><span class="comment"> * initiated by this connection or any of the I/O objects (e.g. resultsets)</span></div><div class="line"><span class="comment"> * associated to them.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">using</span> base_executor_type = boost::asio::io_context::executor_type;</div><div class="line"><span class="keyword">using</span> coro_executor_type = boost::asio::use_awaitable_t&lt;</div><div class="line">    base_executor_type&gt;::executor_with_default&lt;base_executor_type&gt;;</div><div class="line"><span class="keyword">using</span> connection_type = <a class="code" href="structboost_1_1mysql_1_1socket__connection_1_1rebind__executor.html">boost::mysql::tcp_connection::rebind_executor&lt;coro_executor_type&gt;::other</a>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Our coroutine. It must have a return type of boost::asio::awaitable&lt;T&gt;.</span></div><div class="line"><span class="comment"> * Our coroutine does not communicate any result back, so T=void.</span></div><div class="line"><span class="comment"> * Remember that you do not have to explicitly create any awaitable&lt;void&gt; in</span></div><div class="line"><span class="comment"> * your function. Instead, the return type is fed to std::coroutine_traits</span></div><div class="line"><span class="comment"> * to determine the semantics of the coroutine, like the promise type.</span></div><div class="line"><span class="comment"> * Asio already takes care of all this for us.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The coroutine will suspend every time we call one of the asynchronous functions, saving</span></div><div class="line"><span class="comment"> * all information it needs for resuming. When the asynchronous operation completes,</span></div><div class="line"><span class="comment"> * the coroutine will resume in the point it was left.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The return type of an asynchronous operation that uses boost::asio::use_awaitable</span></div><div class="line"><span class="comment"> * as completion token is a boost::asio::awaitable&lt;T&gt;, where T</span></div><div class="line"><span class="comment"> * is the second argument to the handler signature for the asynchronous operation.</span></div><div class="line"><span class="comment"> * For example, connection::query has a handler</span></div><div class="line"><span class="comment"> * signature of void(error_code, resultset&lt;Stream&gt;), so async_query will return</span></div><div class="line"><span class="comment"> * a boost::asio::awaitable&lt;boost::mysql::resultset&lt;Stream&gt;&gt;. The return type of</span></div><div class="line"><span class="comment"> * calling co_await on such a expression would be a boost::mysql::resultset&lt;Stream&gt;.</span></div><div class="line"><span class="comment"> * If any of the asynchronous operations fail, an exception will be raised</span></div><div class="line"><span class="comment"> * within the coroutine.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">boost::asio::awaitable&lt;void, base_executor_type&gt; start_query(</div><div class="line">    <span class="keyword">const</span> boost::asio::io_context::executor_type&amp; ex,</div><div class="line">    <span class="keyword">const</span> boost::asio::ip::tcp::endpoint&amp; ep,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a>&amp; params</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="comment">// Create the connection. We do not use the raw tcp_connection type</span></div><div class="line">    <span class="comment">// alias to default the completion token; see above.</span></div><div class="line">    connection_type conn (ex);</div><div class="line"></div><div class="line">    <span class="comment">// Connect to server. Note: we didn&#39;t have to pass boost::asio::use_awaitable:</span></div><div class="line">    <span class="comment">// go default completion tokens brrrrr</span></div><div class="line">    co_await conn.async_connect(ep, params);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Issue the query to the server. Note that async_query returns a</span></div><div class="line"><span class="comment">     * boost::asio::awaitable&lt;boost::mysql::resultset&lt;socket_type&gt;, base_executor_type&gt;,</span></div><div class="line"><span class="comment">     * where socket_type is a TCP socket bound to coro_executor_type.</span></div><div class="line"><span class="comment">     * Calling co_await on this expression will yield a boost::mysql::resultset&lt;socket_type&gt;.</span></div><div class="line"><span class="comment">     * Note that this is not the same type as a boost::mysql::tcp_resultset because we</span></div><div class="line"><span class="comment">     * used a custom socket type.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;SELECT first_name, last_name, salary FROM employee WHERE company_id = &#39;HGS&#39;&quot;</span>;</div><div class="line">    <span class="keyword">auto</span> result = co_await conn.async_query(sql);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Get all rows in the resultset. We will employ resultset::async_fetch_one(),</span></div><div class="line"><span class="comment">     * which returns a single row at every call. The returned row is a pointer</span></div><div class="line"><span class="comment">     * to memory owned by the resultset, and is re-used for each row. Thus, returned</span></div><div class="line"><span class="comment">     * rows remain valid until the next call to async_fetch_one(). When no more</span></div><div class="line"><span class="comment">     * rows are available, async_fetch_one returns nullptr.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>* row = co_await result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#ab9f1dab2fbf86333c8453cee4e549033">async_fetch_one</a>())</div><div class="line">    {</div><div class="line">        print_employee(*row);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Notify the MySQL server we want to quit, then close the underlying connection.</span></div><div class="line">    co_await conn.async_close();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt;\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// io_context plus runner thread</span></div><div class="line">    application app;</div><div class="line"></div><div class="line">    <span class="comment">// Connection parameters</span></div><div class="line">    boost::asio::ip::tcp::endpoint ep (</div><div class="line">        boost::asio::ip::address_v4::loopback(), <span class="comment">// host</span></div><div class="line">        <a class="code" href="group__connection.html#ga8b06987134c461a221c30c6ef3cdb0d4">boost::mysql::default_port</a>                 <span class="comment">// port</span></div><div class="line">    );</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> params (</div><div class="line">        argv[1],               <span class="comment">// username</span></div><div class="line">        argv[2],               <span class="comment">// password</span></div><div class="line">        <span class="stringliteral">&quot;boost_mysql_examples&quot;</span> <span class="comment">// database to use; leave empty or omit the parameter for no database</span></div><div class="line">    );</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * The entry point. We spawn a thread of execution to run our</span></div><div class="line"><span class="comment">     * coroutine using boost::asio::co_spawn. We pass in a function returning</span></div><div class="line"><span class="comment">     * a boost::asio::awaitable&lt;void&gt;, as required.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * We pass in a callback to co_spawn. It will be called when</span></div><div class="line"><span class="comment">     * the coroutine completes, with an exception_ptr if there was any error</span></div><div class="line"><span class="comment">     * during execution. We use a promise to wait for the coroutine completion</span></div><div class="line"><span class="comment">     * and transmit any raised exception.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">auto</span> executor = app.context().get_executor();</div><div class="line">    std::promise&lt;void&gt; prom;</div><div class="line">    boost::asio::co_spawn(executor, [executor, ep, params] {</div><div class="line">        <span class="keywordflow">return</span> start_query(executor, ep, params);</div><div class="line">    }, [&amp;prom](std::exception_ptr err) {</div><div class="line">        prom.set_exception(std::move(err));</div><div class="line">    });</div><div class="line">    prom.get_future().get();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry, your compiler does not support C++20 coroutines&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="prepared_statements"></a>
Prepared statements</h2>
<p>This example demonstrates preparing statements, executing them and reading back the results. It employs synchronous functions. </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to a localhost MySQL server.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example uses synchronous functions and handles errors using exceptions.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example assumes you are already familiar with the basic concepts</span></div><div class="line"><span class="comment"> * of mysql-asio (tcp_connection, resultset, rows, values). If you are not,</span></div><div class="line"><span class="comment"> * please have a look to the query_sync.cpp example.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ASSERT(expr) \</span></div><div class="line"><span class="preprocessor">    if (!(expr)) \</span></div><div class="line"><span class="preprocessor">    { \</span></div><div class="line"><span class="preprocessor">        std::cerr &lt;&lt; &quot;Assertion failed: &quot; #expr &lt;&lt; std::endl; \</span></div><div class="line"><span class="preprocessor">        exit(1); \</span></div><div class="line"><span class="preprocessor">    }</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt;\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Connection parameters</span></div><div class="line">    boost::asio::ip::tcp::endpoint ep (</div><div class="line">        boost::asio::ip::address_v4::loopback(), <span class="comment">// host</span></div><div class="line">        <a class="code" href="group__connection.html#ga8b06987134c461a221c30c6ef3cdb0d4">boost::mysql::default_port</a>                         <span class="comment">// port</span></div><div class="line">    );</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> params (</div><div class="line">        argv[1],               <span class="comment">// username</span></div><div class="line">        argv[2],               <span class="comment">// password</span></div><div class="line">        <span class="stringliteral">&quot;boost_mysql_examples&quot;</span> <span class="comment">// database to use; leave empty or omit the parameter for no database</span></div><div class="line">    );</div><div class="line"></div><div class="line">    boost::asio::io_context ctx;</div><div class="line"></div><div class="line">    <span class="comment">// Declare the connection object and authenticate to the server</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1socket__connection.html">boost::mysql::tcp_connection</a> conn (ctx);</div><div class="line">    conn.connect(ep, params);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * We can tell MySQL to prepare a statement using connection::prepare_statement.</span></div><div class="line"><span class="comment">     * We provide a string SQL statement, which can include any number of parameters,</span></div><div class="line"><span class="comment">     * identified by question marks. Parameters are optional: you can prepare a statement</span></div><div class="line"><span class="comment">     * with no parameters.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Prepared statements are stored in the server on a per-connection basis.</span></div><div class="line"><span class="comment">     * Once a connection is closed, all prepared statements for that connection are deallocated.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * The result of prepare_statement is a mysql::prepared_statement object, which is</span></div><div class="line"><span class="comment">     * templatized on the stream type of the connection (tcp_prepared_statement in our case).</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * We prepare two statements, a SELECT and an UPDATE.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* salary_getter_sql = <span class="stringliteral">&quot;SELECT salary FROM employee WHERE first_name = ?&quot;</span>;</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1prepared__statement.html">boost::mysql::tcp_prepared_statement</a> salary_getter = conn.prepare_statement(salary_getter_sql);</div><div class="line">    ASSERT(salary_getter.<a class="code" href="classboost_1_1mysql_1_1prepared__statement.html#aac8cb6258129cc7d723a6048f0215fc0">num_params</a>() == 1); <span class="comment">// num_params() returns the number of parameters (question marks)</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* salary_updater_sql = <span class="stringliteral">&quot;UPDATE employee SET salary = ? WHERE first_name = ?&quot;</span>;</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1prepared__statement.html">boost::mysql::tcp_prepared_statement</a> salary_updater = conn.prepare_statement(salary_updater_sql);</div><div class="line">    ASSERT(salary_updater.<a class="code" href="classboost_1_1mysql_1_1prepared__statement.html#aac8cb6258129cc7d723a6048f0215fc0">num_params</a>() == 2);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Once a statement has been prepared, it can be executed as many times as</span></div><div class="line"><span class="comment">     * desired, by calling prepared_statement::execute(). execute takes as input a</span></div><div class="line"><span class="comment">     * (possibly empty) collection of mysql::value&#39;s and returns a resultset.</span></div><div class="line"><span class="comment">     * The returned resultset works the same as the one returned by connection::query().</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * The parameters passed to execute() are replaced in order of declaration:</span></div><div class="line"><span class="comment">     * the first question mark will be replaced by the first passed parameter,</span></div><div class="line"><span class="comment">     * the second question mark by the second parameter and so on. The number</span></div><div class="line"><span class="comment">     * of passed parameters must match exactly the number of parameters for</span></div><div class="line"><span class="comment">     * the prepared statement.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Any collection providing member functions begin() and end() returning</span></div><div class="line"><span class="comment">     * forward iterators to mysql::value&#39;s is acceptable. We use mysql::make_values(),</span></div><div class="line"><span class="comment">     * which creates a std::array with the passed in values converted to mysql::value&#39;s.</span></div><div class="line"><span class="comment">     * An iterator version of execute() is also available.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1resultset.html">boost::mysql::tcp_resultset</a> result = salary_getter.<a class="code" href="classboost_1_1mysql_1_1prepared__statement.html#a065306003e6957c501cb8c04063f06da">execute</a>(boost::mysql::make_values(<span class="stringliteral">&quot;Efficient&quot;</span>));</div><div class="line">    std::vector&lt;boost::mysql::owning_row&gt; salaries = result.fetch_all(); <span class="comment">// Get all the results</span></div><div class="line">    ASSERT(salaries.size() == 1);</div><div class="line">    <span class="keywordtype">double</span> salary = salaries[0].values().at(0).get&lt;<span class="keywordtype">double</span>&gt;(); <span class="comment">// First row, first column</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The salary before the payrise was: &quot;</span> &lt;&lt; salary &lt;&lt; std::endl;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Run the update. In this case, we must pass in two parameters.</span></div><div class="line"><span class="comment">     * Note that MySQL is flexible in the types passed as parameters.</span></div><div class="line"><span class="comment">     * In this case, we are sending the value 35000, which gets converted</span></div><div class="line"><span class="comment">     * into a mysql::value with type std::int32_t, while the &#39;salary&#39;</span></div><div class="line"><span class="comment">     * column is declared as a DOUBLE. The MySQL server will do</span></div><div class="line"><span class="comment">     * the right thing for us.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    salary_updater.<a class="code" href="classboost_1_1mysql_1_1prepared__statement.html#a065306003e6957c501cb8c04063f06da">execute</a>(boost::mysql::make_values(35000, <span class="stringliteral">&quot;Efficient&quot;</span>));</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Execute the select again. We can execute a prepared statement</span></div><div class="line"><span class="comment">     * as many times as we want. We do NOT need to call</span></div><div class="line"><span class="comment">     * connection::prepare_statement() again.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    result = salary_getter.<a class="code" href="classboost_1_1mysql_1_1prepared__statement.html#a065306003e6957c501cb8c04063f06da">execute</a>(boost::mysql::make_values(<span class="stringliteral">&quot;Efficient&quot;</span>));</div><div class="line">    salaries = result.fetch_all();</div><div class="line">    ASSERT(salaries.size() == 1);</div><div class="line">    salary = salaries[0].values().at(0).get&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">    ASSERT(salary == 35000); <span class="comment">// Our update took place, and the dev got his pay rise</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The salary after the payrise was: &quot;</span> &lt;&lt; salary &lt;&lt; std::endl;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Close the statements. Closing a statement deallocates it from the server.</span></div><div class="line"><span class="comment">     * Once a statement is closed, trying to execute it will return an error.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Closing statements implies communicating with the server and can thus fail.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Statements are automatically deallocated once the connection is closed.</span></div><div class="line"><span class="comment">     * If you are re-using connection objects and preparing statements over time,</span></div><div class="line"><span class="comment">     * you should close() your statements to prevent excessive resource usage.</span></div><div class="line"><span class="comment">     * If you are not re-using the connections, or are preparing your statements</span></div><div class="line"><span class="comment">     * just once at application startup, there is no need to perform this step.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    salary_updater.<a class="code" href="classboost_1_1mysql_1_1prepared__statement.html#abe74e8a3f15e5df7731ae793ef1b6c43">close</a>();</div><div class="line">    salary_getter.<a class="code" href="classboost_1_1mysql_1_1prepared__statement.html#abe74e8a3f15e5df7731ae793ef1b6c43">close</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Close the connection</span></div><div class="line">    conn.close();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="metadata"></a>
Metadata</h2>
<p>This example demonstrates inspecting the metadata of a resultset. </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to a localhost MySQL server.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example shows how to use the metadata contained in a resultset.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example assumes you are already familiar with the basic concepts</span></div><div class="line"><span class="comment"> * of mysql-asio (tcp_connection, resultset, rows, values). If you are not,</span></div><div class="line"><span class="comment"> * please have a look to the query_sync.cpp example.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ASSERT(expr) \</span></div><div class="line"><span class="preprocessor">    if (!(expr)) \</span></div><div class="line"><span class="preprocessor">    { \</span></div><div class="line"><span class="preprocessor">        std::cerr &lt;&lt; &quot;Assertion failed: &quot; #expr &lt;&lt; std::endl; \</span></div><div class="line"><span class="preprocessor">        exit(1); \</span></div><div class="line"><span class="preprocessor">    }</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt;\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Connection params (host, port, user, password, database)</span></div><div class="line">    boost::asio::ip::tcp::endpoint ep (boost::asio::ip::address_v4::loopback(), <a class="code" href="group__connection.html#ga8b06987134c461a221c30c6ef3cdb0d4">boost::mysql::default_port</a>);</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> params (argv[1], argv[2], <span class="stringliteral">&quot;boost_mysql_examples&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// TCP and MySQL level connect</span></div><div class="line">    boost::asio::io_context ctx;</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1socket__connection.html">boost::mysql::tcp_connection</a> conn (ctx);</div><div class="line">    conn.connect(ep, params);</div><div class="line"></div><div class="line">    <span class="comment">// Issue the query</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = R<span class="stringliteral">&quot;(</span></div><div class="line"><span class="stringliteral">        SELECT comp.name AS company_name, emp.id AS employee_id</span></div><div class="line"><span class="stringliteral">        FROM employee emp</span></div><div class="line"><span class="stringliteral">        JOIN company comp ON (comp.id = emp.company_id)</span></div><div class="line"><span class="stringliteral">    )&quot;;</span></div><div class="line"><span class="stringliteral">    <a class="code" href="classboost_1_1mysql_1_1resultset.html">boost::mysql::tcp_resultset</a> result = conn.query(sql);</span></div><div class="line"><span class="stringliteral"></span><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Resultsets allow you to access metadata about the fields in the query</span></div><div class="line"><span class="comment">     * using the fields() function, which returns a vector of field_metadata</span></div><div class="line"><span class="comment">     * (one per field in the query, and in the same order as in the query).</span></div><div class="line"><span class="comment">     * You can retrieve the field name, type, number of decimals,</span></div><div class="line"><span class="comment">     * suggested display width, whether the field is part of a key...</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ASSERT(result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#aec87f1181163a455734e7ede0c71e653">fields</a>().size() == 2);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1field__metadata.html">boost::mysql::field_metadata</a>&amp; company_name = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#aec87f1181163a455734e7ede0c71e653">fields</a>()[0];</div><div class="line">    ASSERT(company_name.database() == <span class="stringliteral">&quot;boost_mysql_examples&quot;</span>); <span class="comment">// database name</span></div><div class="line">    ASSERT(company_name.table() == <span class="stringliteral">&quot;comp&quot;</span>);                    <span class="comment">// the alias we assigned to the table in the query</span></div><div class="line">    ASSERT(company_name.original_table() == <span class="stringliteral">&quot;company&quot;</span>);        <span class="comment">// the original table name</span></div><div class="line">    ASSERT(company_name.field_name() == <span class="stringliteral">&quot;company_name&quot;</span>);       <span class="comment">// the name of the field in the query</span></div><div class="line">    ASSERT(company_name.original_field_name() == <span class="stringliteral">&quot;name&quot;</span>);      <span class="comment">// the name of the physical field in the table</span></div><div class="line">    ASSERT(company_name.type() == <a class="code" href="group__resultsets.html#ggac967096c0bd13a9102ea14034766a395ae334e4821b2fa4ff1d5b78c0774a337e">boost::mysql::field_type::varchar</a>); <span class="comment">// we created the field as a VARCHAR</span></div><div class="line">    ASSERT(!company_name.is_primary_key());                    <span class="comment">// field is not a primary key</span></div><div class="line">    ASSERT(!company_name.is_auto_increment());                 <span class="comment">// field is not AUTO_INCREMENT</span></div><div class="line">    ASSERT(company_name.is_not_null());                        <span class="comment">// field may not be NULL</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1field__metadata.html">boost::mysql::field_metadata</a>&amp; employee_id = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#aec87f1181163a455734e7ede0c71e653">fields</a>()[1];</div><div class="line">    ASSERT(employee_id.database() == <span class="stringliteral">&quot;boost_mysql_examples&quot;</span>); <span class="comment">// database name</span></div><div class="line">    ASSERT(employee_id.table() == <span class="stringliteral">&quot;emp&quot;</span>);                   <span class="comment">// the alias we assigned to the table in the query</span></div><div class="line">    ASSERT(employee_id.original_table() == <span class="stringliteral">&quot;employee&quot;</span>);     <span class="comment">// the original table name</span></div><div class="line">    ASSERT(employee_id.field_name() == <span class="stringliteral">&quot;employee_id&quot;</span>);      <span class="comment">// the name of the field in the query</span></div><div class="line">    ASSERT(employee_id.original_field_name() == <span class="stringliteral">&quot;id&quot;</span>);      <span class="comment">// the name of the physical field in the table</span></div><div class="line">    ASSERT(employee_id.type() == <a class="code" href="group__resultsets.html#ggac967096c0bd13a9102ea14034766a395ad7488204e92ed01986284bef5650eb53">boost::mysql::field_type::int_</a>);  <span class="comment">// we created the field as INT</span></div><div class="line">    ASSERT(employee_id.is_primary_key());                   <span class="comment">// field is a primary key</span></div><div class="line">    ASSERT(employee_id.is_auto_increment());                <span class="comment">// we declared the field as AUTO_INCREMENT</span></div><div class="line">    ASSERT(employee_id.is_not_null());                      <span class="comment">// field cannot be NULL</span></div><div class="line"></div><div class="line">    <span class="comment">// Close the connection</span></div><div class="line">    conn.close();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="unix_socket"></a>
UNIX domain sockets</h2>
<p>This example demonstrates connecting to a MySQL server over a UNIX domain socket. It employs synchronous functions with exceptions. </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Copyright (c) 2019-2020 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span></div><div class="line"><span class="comment">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;boost/mysql/mysql.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio/io_context.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/system/system_error.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * For this example, we will be using the &#39;boost_mysql_examples&#39; database.</span></div><div class="line"><span class="comment"> * You can get this database by running db_setup.sql.</span></div><div class="line"><span class="comment"> * This example assumes you are connecting to MySQL server using</span></div><div class="line"><span class="comment"> * a UNIX socket. The socket path can be configured using command line</span></div><div class="line"><span class="comment"> * arguments, and defaults to /var/run/mysqld/mysqld.sock</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This example uses synchronous functions and handles errors using exceptions.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> print_employee(<span class="keyword">const</span> <a class="code" href="classboost_1_1mysql_1_1row.html">boost::mysql::row</a>&amp; employee)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Employee &#39;&quot;</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>                   <span class="comment">// first_name (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[1] &lt;&lt; <span class="stringliteral">&quot;&#39; earns &quot;</span>            <span class="comment">// last_name  (type boost::string_view)</span></div><div class="line">              &lt;&lt; employee.<a class="code" href="classboost_1_1mysql_1_1row.html#abf57faf0417c0b68af482ebf01db576a">values</a>()[2] &lt;&lt; <span class="stringliteral">&quot; dollars yearly\n&quot;</span>;  <span class="comment">// salary     (type double)</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#define ASSERT(expr) \</span></div><div class="line"><span class="preprocessor">    if (!(expr)) \</span></div><div class="line"><span class="preprocessor">    { \</span></div><div class="line"><span class="preprocessor">        std::cerr &lt;&lt; &quot;Assertion failed: &quot; #expr &lt;&lt; std::endl; \</span></div><div class="line"><span class="preprocessor">        exit(1); \</span></div><div class="line"><span class="preprocessor">    }</span></div><div class="line"></div><div class="line"><span class="comment">// UNIX sockets are only available in, er, UNIX systems. Typedefs for</span></div><div class="line"><span class="comment">// UNIX socket-based connections are only available in UNIX systems.</span></div><div class="line"><span class="comment">// Check for BOOST_ASIO_HAS_LOCAL_SOCKETS to know if UNIX socket</span></div><div class="line"><span class="comment">// typedefs are available in your system.</span></div><div class="line"><span class="preprocessor">#ifdef BOOST_ASIO_HAS_LOCAL_SOCKETS</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 3 &amp;&amp; argc != 4)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;username&gt; &lt;password&gt; [&lt;socket-path&gt;]\n&quot;</span>;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* socket_path = <span class="stringliteral">&quot;/var/run/mysqld/mysqld.sock&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (argc == 4)</div><div class="line">    {</div><div class="line">        socket_path = argv[3];</div><div class="line">    }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Connection parameters that tell us where and how to connect to the MySQL server.</span></div><div class="line"><span class="comment">     * There are two types of parameters:</span></div><div class="line"><span class="comment">     *   - UNIX-level connection parameters, identifying the UNIX socket to connect to.</span></div><div class="line"><span class="comment">     *   - MySQL level parameters: database credentials and schema to use.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    boost::asio::local::stream_protocol::endpoint ep (socket_path);</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1connection__params.html">boost::mysql::connection_params</a> params (</div><div class="line">        argv[1],               <span class="comment">// username</span></div><div class="line">        argv[2],               <span class="comment">// password</span></div><div class="line">        <span class="stringliteral">&quot;boost_mysql_examples&quot;</span> <span class="comment">// database to use; leave empty or omit the parameter for no database</span></div><div class="line">    );</div><div class="line">    <span class="comment">// Note: by default, SSL will be used if the server supports it.</span></div><div class="line">    <span class="comment">// connection_params accepts an optional ssl_options argument</span></div><div class="line">    <span class="comment">// determining whether to use SSL or not. See ssl_options and ssl_mode</span></div><div class="line">    <span class="comment">// documentation for further details on SSL.</span></div><div class="line"></div><div class="line">    boost::asio::io_context ctx;</div><div class="line"></div><div class="line">    <span class="comment">// Connection to the MySQL server, over a UNIX socket</span></div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1socket__connection.html">boost::mysql::unix_connection</a> conn (ctx);</div><div class="line">    conn.connect(ep, params); <span class="comment">// UNIX socket connect and MySQL handshake</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* sql = <span class="stringliteral">&quot;SELECT first_name, last_name, salary FROM employee WHERE company_id = &#39;HGS&#39;&quot;</span>;</div><div class="line">    <a class="code" href="classboost_1_1mysql_1_1resultset.html">boost::mysql::unix_resultset</a> result = conn.query(sql);</div><div class="line"></div><div class="line">    <span class="comment">// Get all the rows in the resultset</span></div><div class="line">    std::vector&lt;boost::mysql::owning_row&gt; employees = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#ae55f09ab6291e867e67a3a1a30304df7">fetch_all</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; employee: employees)</div><div class="line">    {</div><div class="line">        print_employee(employee);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// We can issue any SQL statement, not only SELECTs. In this case, the returned</span></div><div class="line">    <span class="comment">// resultset will have no fields and no rows</span></div><div class="line">    sql = <span class="stringliteral">&quot;UPDATE employee SET salary = 10000 WHERE first_name = &#39;Underpaid&#39;&quot;</span>;</div><div class="line">    result = conn.query(sql);</div><div class="line">    ASSERT(result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#aec87f1181163a455734e7ede0c71e653">fields</a>().size() == 0); <span class="comment">// fields() returns a vector containing metadata about the query fields</span></div><div class="line"></div><div class="line">    <span class="comment">// Check we have updated our poor intern salary</span></div><div class="line">    result = conn.query(<span class="stringliteral">&quot;SELECT salary FROM employee WHERE first_name = &#39;Underpaid&#39;&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> rows = result.<a class="code" href="classboost_1_1mysql_1_1resultset.html#ae55f09ab6291e867e67a3a1a30304df7">fetch_all</a>();</div><div class="line">    ASSERT(rows.size() == 1);</div><div class="line">    <span class="keywordtype">double</span> salary = rows[0].values()[0].get&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">    ASSERT(salary == 10000);</div><div class="line"></div><div class="line">    <span class="comment">// Notify the MySQL server we want to quit, then close the underlying connection.</span></div><div class="line">    conn.close();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main_impl(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry, your system does not support UNIX sockets&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        main_impl(argc, argv);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> boost::system::system_error&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; <span class="stringliteral">&quot;, error code: &quot;</span> &lt;&lt; err.code() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; err)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
